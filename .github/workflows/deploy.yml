name: Deploy to Production

on:
  workflow_run:
    workflows: ["Build and Push Docker Image"]
    types:
      - completed
  workflow_dispatch:

jobs:
  deploy:
    if: ${{ github.event.workflow_run.conclusion == 'success' || github.event_name == 'workflow_dispatch' }}
    runs-on: ubuntu-latest
    permissions:
      contents: read
      actions: read
    env:
      SSH_USER: ${{ secrets.SSH_USER }}
      SERVER_HOST: ${{ secrets.SERVER_HOST }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup SSH
        uses: webfactory/ssh-agent@v0.9.0
        with:
          ssh-private-key: ${{ secrets.SSH_PRIVATE_KEY }}

      - name: Add server to known hosts
        run: |
          ssh-keyscan -H "$SERVER_HOST" >> ~/.ssh/known_hosts

      - name: Deploy to server
        run: |
          ssh "$SSH_USER@$SERVER_HOST" << 'EOF'
            set -e
            cd /opt/bartech
            
            # Проверка наличия .env файла
            if [ ! -f .env ]; then
              echo "ERROR: .env file not found!"
              exit 1
            fi
            
            # Создание Docker volumes, если их нет
            echo "Checking Docker volumes..."
            if ! docker volume ls | grep -q "technobar_certbot-etc"; then
              echo "Creating volume technobar_certbot-etc..."
              docker volume create technobar_certbot-etc
            fi
            if ! docker volume ls | grep -q "technobar_certbot-var"; then
              echo "Creating volume technobar_certbot-var..."
              docker volume create technobar_certbot-var
            fi
            echo "Volumes ready"
            
            # Загрузка переменных из .env файла
            set -a
            source .env
            set +a
            
            # Проверка переменных окружения
            echo "Checking environment variables..."
            if [ -z "$DOCKERHUB_USERNAME" ]; then
              echo "ERROR: DOCKERHUB_USERNAME not set in .env file!"
              exit 1
            fi
            if [ -z "$NEXT_PUBLIC_SUPABASE_URL" ]; then
              echo "WARNING: NEXT_PUBLIC_SUPABASE_URL not set in .env file!"
            fi
            if [ -z "$NEXT_PUBLIC_SUPABASE_ANON_KEY" ]; then
              echo "WARNING: NEXT_PUBLIC_SUPABASE_ANON_KEY not set in .env file!"
            fi
            echo "DOCKERHUB_USERNAME: $DOCKERHUB_USERNAME"
            
            # Сохраняем информацию о старом образе для сравнения
            echo "Checking current image..."
            OLD_IMAGE_ID=$(docker images ${DOCKERHUB_USERNAME}/bartech:latest --format "{{.ID}}" 2>/dev/null || echo "")
            if [ -n "$OLD_IMAGE_ID" ]; then
              echo "Current image ID: $OLD_IMAGE_ID"
              docker images ${DOCKERHUB_USERNAME}/bartech:latest --format "table {{.Repository}}\t{{.Tag}}\t{{.ID}}\t{{.CreatedAt}}"
            fi
            
            # Удаление всех старых образов bartech для принудительного обновления
            echo "Removing all old bartech images to force update..."
            docker images ${DOCKERHUB_USERNAME}/bartech --format "{{.ID}}" | xargs -r docker rmi -f 2>/dev/null || true
            
            # Очистка кеша Docker для гарантии свежего pull
            echo "Pruning Docker build cache..."
            docker builder prune -f || true
            
            # Принудительный pull образа (всегда загружает последнюю версию из registry)
            echo "Force pulling latest image from registry..."
            docker pull ${DOCKERHUB_USERNAME}/bartech:latest || {
              echo "ERROR: Failed to pull image ${DOCKERHUB_USERNAME}/bartech:latest"
              echo "Available images:"
              docker images | grep bartech || echo "No bartech images found"
              exit 1
            }
            
            # Проверка, что образ был загружен
            NEW_IMAGE_ID=$(docker images ${DOCKERHUB_USERNAME}/bartech:latest --format "{{.ID}}" 2>/dev/null)
            if [ -z "$NEW_IMAGE_ID" ]; then
              echo "ERROR: Failed to pull image ${DOCKERHUB_USERNAME}/bartech:latest"
              echo "Available images:"
              docker images | grep bartech || echo "No bartech images found"
              exit 1
            fi
            
            echo "Image pulled successfully: ${DOCKERHUB_USERNAME}/bartech:latest"
            echo "New image ID: $NEW_IMAGE_ID"
            
            # Проверка, что образ действительно обновился
            if [ -n "$OLD_IMAGE_ID" ] && [ "$OLD_IMAGE_ID" = "$NEW_IMAGE_ID" ]; then
              echo "⚠️  WARNING: Image ID hasn't changed! The image might not have been updated."
              echo "This could mean the image in Docker Hub is the same as before."
            else
              echo "✅ Image updated successfully (old: ${OLD_IMAGE_ID:-none}, new: $NEW_IMAGE_ID)"
            fi
            
            # Показываем детальную информацию об образе для отладки
            echo "Image details:"
            docker images ${DOCKERHUB_USERNAME}/bartech:latest --format "table {{.Repository}}\t{{.Tag}}\t{{.ID}}\t{{.CreatedAt}}\t{{.Size}}"
            docker inspect ${DOCKERHUB_USERNAME}/bartech:latest --format "Created: {{.Created}}, Digest: {{.RepoDigests}}" || true
            
            # Остановка старых контейнеров
            echo "Stopping old containers..."
            docker-compose -f docker-compose.yml -f docker-compose.prod.yml down || true
            
            # Удаление старых контейнеров для гарантии чистого запуска
            echo "Removing old containers..."
            docker rm -f bartech-nextjs bartech-nginx bartech-certbot 2>/dev/null || true
            
            # Удаление старых volumes контейнера (если есть) для полной очистки
            echo "Cleaning up any orphaned volumes..."
            docker volume prune -f || true
            
            # Запуск новых контейнеров (без кеша, принудительно пересоздавая)
            echo "Starting containers with --force-recreate and --no-deps..."
            docker-compose -f docker-compose.yml -f docker-compose.prod.yml up -d --force-recreate --remove-orphans --no-deps nextjs || {
              echo "Failed to start with --no-deps, trying without..."
              docker-compose -f docker-compose.yml -f docker-compose.prod.yml up -d --force-recreate --remove-orphans
            }
            
            # Проверка, что контейнер использует правильный образ
            echo "Verifying container is using the new image..."
            CONTAINER_IMAGE_ID=$(docker inspect bartech-nextjs --format "{{.Image}}" 2>/dev/null || echo "")
            if [ -n "$CONTAINER_IMAGE_ID" ] && [ "$CONTAINER_IMAGE_ID" != "$NEW_IMAGE_ID" ]; then
              echo "⚠️  WARNING: Container might not be using the latest image!"
              echo "Container image: $CONTAINER_IMAGE_ID"
              echo "Expected image: $NEW_IMAGE_ID"
            else
              echo "✅ Container is using the correct image"
            fi
            
            # Ожидание запуска контейнеров
            echo "Waiting for containers to start..."
            sleep 5
            
            # Проверка статуса контейнеров
            echo "Checking container status..."
            docker-compose -f docker-compose.yml -f docker-compose.prod.yml ps
            
            # Ожидание готовности Next.js (проверка health check)
            echo "Waiting for Next.js to be ready..."
            max_attempts=30
            attempt=0
            while [ $attempt -lt $max_attempts ]; do
              if docker-compose -f docker-compose.yml -f docker-compose.prod.yml exec -T nextjs node -e "require('http').get('http://127.0.0.1:3000/api/health', (r) => {process.exit(r.statusCode === 200 ? 0 : 1)})" 2>/dev/null; then
                echo "Next.js is ready!"
                break
              fi
              attempt=$((attempt + 1))
              echo "Attempt $attempt/$max_attempts: Next.js not ready yet, waiting..."
              sleep 2
            done
            
            if [ $attempt -eq $max_attempts ]; then
              echo "ERROR: Next.js failed to start after $max_attempts attempts"
              echo "Next.js logs:"
              docker-compose -f docker-compose.yml -f docker-compose.prod.yml logs nextjs --tail=50
              exit 1
            fi
            
            # Перезагрузка Nginx после готовности Next.js
            echo "Reloading Nginx..."
            docker-compose -f docker-compose.yml -f docker-compose.prod.yml exec -T nginx nginx -s reload || true
            
            # Очистка кеша Next.js внутри контейнера (если есть)
            echo "Clearing Next.js cache if needed..."
            docker-compose -f docker-compose.yml -f docker-compose.prod.yml exec -T nextjs sh -c "rm -rf /app/.next/cache/* 2>/dev/null || true" || true
            
            # Очистка старых образов (кроме текущего)
            echo "Cleaning up old images (keeping current)..."
            docker images ${DOCKERHUB_USERNAME}/bartech --format "{{.ID}} {{.Tag}}" | grep -v "latest\|$NEW_IMAGE_ID" | awk '{print $1}' | xargs -r docker rmi -f 2>/dev/null || true
            docker image prune -f
            
            # Проверка, что приложение работает и возвращает данные
            echo "Verifying application is serving fresh data..."
            sleep 3
            if docker-compose -f docker-compose.yml -f docker-compose.prod.yml exec -T nextjs node -e "require('http').get('http://127.0.0.1:3000/api/health', (r) => {process.exit(r.statusCode === 200 ? 0 : 1)})" 2>/dev/null; then
              echo "✅ Application is running and health check passed"
            else
              echo "⚠️  Warning: Health check failed after deployment"
            fi
            
            echo "Deployment completed successfully!"
          EOF

      - name: Health check
        run: |
          echo "Waiting for application to be fully ready..."
          sleep 15
          
          max_attempts=10
          attempt=0
          while [ $attempt -lt $max_attempts ]; do
            if curl -f https://technobar.by/api/health; then
              echo "Health check passed!"
              exit 0
            fi
            attempt=$((attempt + 1))
            echo "Health check attempt $attempt/$max_attempts failed, retrying..."
            sleep 5
          done
          
          echo "ERROR: Health check failed after $max_attempts attempts"
          ssh "$SSH_USER@$SERVER_HOST" << 'EOF'
            cd /opt/bartech
            echo "=== Container Status ==="
            docker-compose -f docker-compose.yml -f docker-compose.prod.yml ps
            echo "=== Next.js Logs ==="
            docker-compose -f docker-compose.yml -f docker-compose.prod.yml logs nextjs --tail=50
            echo "=== Nginx Logs ==="
            docker-compose -f docker-compose.yml -f docker-compose.prod.yml logs nginx --tail=50
          EOF
          exit 1

